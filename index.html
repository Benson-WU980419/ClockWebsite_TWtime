<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>網頁時鐘</title>
    <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Major+Mono+Display&display=swap" rel="stylesheet">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="iPhone 時鐘">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Benson-WU980419/ClockWebsite_TWtime/refs/heads/main/clockwebsite_twtime_icon.png">
    <link rel="icon" href="https://raw.githubusercontent.com/Benson-WU980419/ClockWebsite_TWtime/refs/heads/main/clockwebsite_twtime_icon.png" type="image/png">

    <style>
        /* 整體頁面樣式 */
        body {
            background-color: #000; /* 純黑色背景，適合深色模式 */
            color: #FFF; /* 白色文字 (主要用於校正訊息，時間顏色會被覆蓋) */
            font-family: 'Lobster', cursive; /* 頁面主要字體仍使用 Lobster，營造整體風格 */
            font-weight: normal; /* Lobster 字體本身就較粗，不需要額外設定 bold */
            display: flex; /* 使用 Flexbox 讓內容居中 */
            flex-direction: column; /* 垂直排列時間和訊息 */
            justify-content: center; /* 垂直居中 */
            align-items: center; /* 水平居中 */
            height: 100vh; /* 佔滿整個視口高度 */
            margin: 0; /* 移除預設外邊距 */
            overflow: hidden; /* 防止頁面出現滾動條 */
            user-select: none; /* 防止使用者選取文字，提升作為時鐘的體驗 */
            -webkit-user-select: none; /* 針對 Safari 瀏覽器 */
            -moz-user-select: none; /* 針對 Firefox 瀏覽器 */
            -ms-user-select: none; /* 針對 IE/Edge 瀏覽器 */
            /* 針對 iOS 設備的安全區域，確保內容不會被瀏海或底部條遮擋 */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* 時間顯示區塊樣式 */
        #time {
            /* 字體大小根據視口寬度自動調整，確保不超出螢幕且不換行 */
            font-size: 15vw; 
            text-align: center; /* 文字居中 */
            /* 調整字體間距以適應 Major Mono Display 的風格 */
            letter-spacing: -0.05em; 
            
            /* 輝光管風格顏色和發光效果 */
            color: #FF8C00; /* 輝光管的橙紅色 */
            text-shadow: 
                0 0 5px rgba(255, 140, 0, 0.8),   /* 較近的柔和光暈 */
                0 0 15px rgba(255, 140, 0, 0.6),  /* 中等範圍的光暈 */
                0 0 30px rgba(255, 140, 0, 0.4);  /* 較遠的擴散光暈 */
            
            position: relative; /* 允許使用 transform 進行定位偏移 */
            transition: transform 5s ease-in-out; /* 設置平滑的過渡效果，讓移動不那麼突兀 */
            line-height: 1; /* 確保行高緊湊，避免多餘的垂直空間 */
            /* 使用 Major Mono Display 作為時間數字字體，並提供通用等寬字體作為備用 */
            font-family: 'Major Mono Display', monospace; 
            white-space: nowrap; /* 防止時間顯示換行 */
        }

        /* 校正訊息區塊樣式 */
        #calibration-message {
            font-size: 3.5vw; /* 稍微增大校正訊息字體 */
            color: rgba(255, 255, 255, 0.6); /* 稍微淡一點的白色，與時間區分開 */
            margin-top: 3vh; /* 增加與時間顯示的間距 */
            text-align: center;
            /* 校正訊息字體保持微軟正黑 */
            font-family: 'Microsoft JhengHei', '微軟正黑體', sans-serif;
            font-weight: normal;
        }
    </style>
</head>
<body>
    <div id="time"></div>
    <div id="calibration-message"></div>

    <script>
        /**
         * @class Clock
         * @description 管理時鐘的顯示、螢幕保護、時間校準和自動微調邏輯。
         */
        class Clock {
            /**
             * @constructor
             * @param {string} timeElementId - 顯示時間的 DOM 元素 ID。
             * @param {string} messageElementId - 顯示校正訊息的 DOM 元素 ID。
             */
            constructor(timeElementId, messageElementId) {
                this.timeElement = document.getElementById(timeElementId);
                this.messageElement = document.getElementById(messageElementId);

                // 儲存伺服器時間與本地時間的偏移量 (毫秒)
                // 初始為 0，表示使用本地時間。校準後會更新。
                this.timeOffset = 0; 
                // 動態調整時鐘運行速度的變數 (毫秒/秒)
                // 正值會讓時鐘加速，負值會讓時鐘減速。
                this.currentRateAdjustment = 0; 
                // 用於追蹤上次 updateTime 執行時的時間，以便計算經過的時間
                this.lastUpdateTime = Date.now(); 
                // 預設調快一秒的固定偏移量 (毫秒)
                this.desiredInitialFastForward = 1000; 

                // 校準相關參數
                // 使用 worldtimeapi.org 作為時間 API
                this.timeApiUrl = 'https://worldtimeapi.org/api/ip'; 
                this.calibrationAttempts = 3; // 校準重試次數
                this.calibrationDelay = 5000; // 校準重試間隔 (毫秒)
                this.calibrationIntervalSeconds = 60; // 校準間隔 (秒)
                this.adjustmentFactor = 0.9; // 調整因子 (0 到 1 之間)，決定每次調整的激進程度。提高以更積極。
                this.maxRateAdjustment = 100; // 限制速率調整的最大範圍 (毫秒/秒)
            }

            /**
             * @method updateTime
             * @description 更新時間顯示，每秒執行一次。
             * 顯示的時間是基於本地時間加上校正後的偏移量，並根據自動微調加速。
             */
            updateTime() {
                const now = Date.now();
                // 計算自上次更新以來經過的時間 (毫秒)
                const elapsedTime = now - this.lastUpdateTime; 
                this.lastUpdateTime = now; // 更新上次更新時間

                // 根據 currentRateAdjustment (毫秒/秒) 和經過的時間，調整 timeOffset
                // 這會讓時鐘的運行速度根據校準結果動態調整
                this.timeOffset += (this.currentRateAdjustment * (elapsedTime / 1000));

                // 獲取當前本地時間的毫秒數，並加上校正偏移量
                // desiredInitialFastForward 已經在校準時加入到 timeOffset 中
                let synchronizedTimestamp = now + this.timeOffset; 
                
                const synchronizedTime = new Date(synchronizedTimestamp);

                let hours = synchronizedTime.getHours();
                let minutes = synchronizedTime.getMinutes();
                let seconds = synchronizedTime.getSeconds();

                // 格式化時間，確保小時、分鐘、秒數都以兩位數顯示 (例如 01:05:09)
                hours = hours < 10 ? '0' + hours : hours;
                minutes = minutes < 10 ? '0' + minutes : minutes;
                seconds = seconds < 10 ? '0' + seconds : seconds;

                // 將格式化後的時間顯示在頁面上，使用全形冒號
                this.timeElement.textContent = `${hours}：${minutes}：${seconds}`;

                // 在控制台輸出調整數值，以便觀察 (可取消註釋)
                // console.log(`[UpdateTime] Elapsed: ${elapsedTime}ms, Rate Adj: ${this.currentRateAdjustment.toFixed(3)}ms/s, TimeOffset: ${this.timeOffset.toFixed(2)}ms, Synced Time: ${synchronizedTime.toLocaleTimeString()}`);
            }

            /**
             * @method applyScreenProtection
             * @description 輕微移動時間顯示的位置，以防止螢幕燒屏。
             */
            applyScreenProtection() {
                // 生成一個小範圍的隨機偏移量，例如在 -1.5vw 到 +1.5vw 之間
                const offsetX = (Math.random() * 2 - 1) * 1.5; // 隨機生成 -1.5 到 +1.5 之間的 vw 偏移量
                const offsetY = (Math.random() * 2 - 1) * 1.5; // 隨機生成 -1.5 到 +1.5 之間的 vh 偏移量

                // 將計算出的偏移量應用到時間元素的 transform 屬性上
                this.timeElement.style.transform = `translate(${offsetX}vw, ${offsetY}vh)`;
            }

            /**
             * @method startCalibration
             * @description 啟動校正過程，顯示校正訊息，並從外部 API 獲取精確時間進行校正。
             * 包含重試機制和詳細錯誤回饋。
             * **新增自動微調邏輯：根據新的時間偏移量調整時鐘速率。**
             */
            async startCalibration() {
                this.messageElement.textContent = '正在與外部時間校正...'; // 顯示校正中訊息
                
                let attemptsLeft = this.calibrationAttempts;
                while (attemptsLeft > 0) {
                    try {
                        // 從 WorldTimeAPI 獲取基於 IP 的時間資訊
                        const response = await fetch(this.timeApiUrl, { mode: 'cors' });
                        
                        if (!response.ok) {
                            // 如果響應狀態不是 2xx，則拋出錯誤
                            const errorText = await response.text(); 
                            throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}. Response body: ${errorText}`);
                        }
                        const data = await response.json();
                        
                        // worldtimeapi.org 的 UTC 時間在 utc_datetime 欄位
                        const serverUtcTime = new Date(data.utc_datetime);
                        const localNow = new Date();

                        // 計算伺服器時間與本地時間的差異 (實際的瞬間偏差)
                        const actualTimeDifference = serverUtcTime.getTime() - localNow.getTime(); 
                        
                        // 將「預設調快一秒」的偏移量加入到 timeOffset 中
                        // timeOffset 現在代表了 (伺服器時間 - 本地時間) + 預設加速
                        this.timeOffset = actualTimeDifference + this.desiredInitialFastForward;

                        // --- 自動微調邏輯 ---
                        // 目標：讓時鐘的運行速度更精確地趨近於外部時間。
                        // desiredRateAdjustment 應該基於實際的偏差 (actualTimeDifference) 來計算。
                        // 如果 actualTimeDifference 是正值，表示我們的時鐘比外部時間慢了這麼多毫秒。
                        // 我們需要在下一個校準間隔內，將時鐘加速這麼多。
                        const desiredRateAdjustment = actualTimeDifference / this.calibrationIntervalSeconds;

                        // 逐步調整 currentRateAdjustment 趨近於 desiredRateAdjustment
                        this.currentRateAdjustment = (this.currentRateAdjustment * (1 - this.adjustmentFactor)) + (desiredRateAdjustment * this.adjustmentFactor);

                        // 限制速率調整的範圍，防止出現極端值
                        this.currentRateAdjustment = Math.max(-this.maxRateAdjustment, Math.min(this.maxRateAdjustment, this.currentRateAdjustment)); 
                        
                        console.log(`[Calibration Success] 實際時間差異: ${actualTimeDifference}ms`);
                        console.log(`[Calibration Success] 校準後總時間偏移量 (含預設加速): ${this.timeOffset}ms`);
                        console.log(`[Calibration Success] 新速率調整: ${this.currentRateAdjustment.toFixed(3)}ms/s`);
                        // --- 自動微調邏輯結束 ---

                        this.messageElement.textContent = '校正完成'; // 校正成功訊息
                        setTimeout(() => this.messageElement.textContent = '', 2000);
                        return; // 校準成功，退出迴圈
                    } catch (error) {
                        console.error('時間校正失敗:', error);
                        attemptsLeft--; // 減少嘗試次數

                        if (attemptsLeft === 0) {
                            // 如果所有嘗試都失敗了
                            this.messageElement.textContent = '校正失敗 (網路或安全策略問題)'; // 顯示最終失敗訊息
                            // 校正失敗，timeOffset 回歸僅預設調快一秒的本地時間
                            this.timeOffset = this.desiredInitialFastForward; 
                            this.currentRateAdjustment = 0; // 同時重置速率調整，避免累積錯誤
                            console.error('可能原因：網路連接問題，或瀏覽器/環境的安全策略 (CSP) 阻止了對外部 API 的請求。');
                            console.error('請確保您的網路連接正常，並且如果是在受限環境中運行，該環境允許對 worldtimeapi.org 的 HTTPS 請求。');
                        } else {
                            // 等待一段時間後再重試
                            await new Promise(resolve => setTimeout(resolve, this.calibrationDelay));
                        }
                    }
                }
                // 如果所有嘗試都失敗，且訊息尚未清除，則在最後清除它
                setTimeout(() => this.messageElement.textContent = '', 2000);
            }

            /**
             * @method init
             * @description 初始化時鐘功能，設定所有定時器。
             */
            init() {
                // 頁面載入時，立即更新一次時間、應用一次螢幕保護，並在首次校正前清空訊息
                this.updateTime();
                this.applyScreenProtection();
                this.messageElement.textContent = ''; // 確保初始是空的

                // 設定定時器：每秒更新一次時間顯示
                setInterval(() => this.updateTime(), 1000);

                // 設定定時器：每 10 秒移動一次時間顯示，啟動螢幕保護功能
                setInterval(() => this.applyScreenProtection(), 10000); // 10000 毫秒 = 10 秒

                // 設定定時器：每 60 秒 (1 分鐘) 啟動一次校正
                setInterval(() => this.startCalibration(), this.calibrationIntervalSeconds * 1000); 

                // 頁面載入後立即執行一次校正
                this.startCalibration();
            }
        }

        // 頁面載入完成後，實例化 Clock 類別並初始化
        document.addEventListener('DOMContentLoaded', () => {
            const myClock = new Clock('time', 'calibration-message');
            myClock.init();
        });
    </script>
</body>
</html>
